from selenium import webdriver
from selenium.webdriver.common.by import By
import time

driver = webdriver.Chrome()
url = 'https://www.amazon.com'
driver.get(url)
time.sleep(10)

# (By.ID, selector)
#Descripción: Este es el primer localizador que debemos tratar de utilizar pues la mayoría de las veces identifican de forma única al elemento.
#Desventajas: A veces el id se auto genera automáticamente y es difícil sino imposible predecirlo. En ocasiones los elementos carecen totalmente de un id.

# Usage: Searches for elements using the ID attribute.
# Pros: IDs are usually unique, making this the most reliable way to locate an element.
# Cons: Sometimes, IDs are autogenerated or missing entirely, which makes it harder to predict or use them.
# selector = 'productTitle' returns what's inside the id tag

search_button_selector = 'nav-search-submit-button' # returns the search input box element
search_button = driver.find_element(By.ID, search_button_selector) # searches the page for an element with that specific ID. If it finds the element, it returns it as a web_element object for further interaction. find_element only shows first ocurrence of the element


# (By.NAME, selector)
# Descripción: Este localizador es el segundo que debemos tratar de utilizar en caso que no tengamos un id. Usualmente los nombre de los elementos son únicos y nos permiten ubicar un elemento con facilidad.
# Desventajas: En ocasiones los nombre de los elementos pueden no ser únicos. Algunos elementos pueden carecer del atributo name.

# Usage: Locates an element using the name attribute.
# Pros: If the name is unique, it’s an easy way to find elements.
# Cons: Not all elements have a name, and multiple elements might share the same name.

searcher_selector = 'field-keywords'
searcher = driver.find_element(By.NAME, searcher_selector)
searcher.send_keys('mouse')

search_button.click()


# (By.CLASS_NAME, selector)[class=""]
# Descripción: Este localizador se refiere al atributo class del elemento Web.
# Desventajas: Normalmente varios tipos de elementos comparten la misma clase por lo que es útil para encontrar un conjunto de elementos (driver.findElements()), de lo contrario haría referencia al primer elemento que contenga ese atributo class.

# Usage: Finds elements based on their class attribute.
# Pros: Useful for selecting multiple elements with the same class.
# Cons: Not always reliable if many elements share the same class.

add_cart_selector = 'puis-atcb-container'
add_cart = driver.find_elements(By.CLASS_NAME, add_cart_selector) # find_elements acts as a list
print(f'Hay {len(add_cart)} elementos en esta página para añadir al carrito') # f is a python function that allows embed expressions or variables directly inside the string
time.sleep(2)


# (By.TAG_NAME, selector) (div, img, input)
# Descripción: Este localizador busca por el nombre del tag (etiqueta) del elemento dentro del DOM(Document Object Model)
# Desventajas: Pueden haber varios elementos con el mismo nombre de etiqueta (Ej. <button>)

# Usage: Searches by the tag name of the element (e.g., <input>, <button>).
# Cons: Many elements share the same tag, making it less precise.

images_selector = 'img'
images = driver.find_elements(By.TAG_NAME, images_selector)
print(f'Hay {len(images)} imágenes en esta página') # solo detecta las imágenes visibles, no las ocultas


# (By.LINK_TEXT, selector)
# Descripción: Este localizador busca links (hipervínculos) en la página donde el texto coincida con el parámetro que le pasamos al método linkText().
# Desventajas: Puede resultar engorroso si hay más de un link en la página con el mismo texto. (Ej. “Read more”)

# Usage: Locates links on the page where the displayed text matches exactly.
# Cons: Ambiguous if multiple links have the same text (e.g., “Read more”).

msg_continue_selector = 'a-button-input'
msg_continue_button = driver.find_element(By.CLASS_NAME, msg_continue_selector)
msg_continue_button.click()


link_text_selector = 'Ofertas del Día'
link_text = driver.find_element(By.LINK_TEXT, link_text_selector)
link_text.click()
time.sleep(2) # esperar por si renderizan otras opciones
driver.back() # go back
time.sleep(1)


# (By.PARTIAL_LINK_TEXT, selector)
# Descripción: Este localizador busca links en la página donde el texto coincida parcialmente con el parámetro que le pasamos al método partialLinkText(“string”).
# Desventajas: Puede resultar engorroso si hay más de un link en la página que comparten ese texto que coincide parcialmente con el texto del link

# Usage: Similar to LINK_TEXT, but it matches part of the link text.
# Cons: Can become ambiguous if many links share similar text.

partial_link_text_selector = 'Ofertas'
partial_link_text = driver.find_element(By.PARTIAL_LINK_TEXT, partial_link_text_selector)
partial_link_text.click()
time.sleep(2)
driver.back()
time.sleep(1)


# (By.CSS_SELECTOR, selector) (“input[name=’q’]”)
# Descripción: Este localizador es en sí una estrategia de localización que utiliza el lenguaje CSS.
# Desventajas: No todos los navegadores manejan de igual forma los css por lo que en algunos podrían funcionar y en otros no. Se necesitan conocimientos de css selector.

# Usage: Uses CSS selectors to identify elements based on styles or attributes.
# Cons: Requires knowledge of CSS syntax, and not all browsers handle CSS selectors equally well.

items_title_selector = 'span[class="a-size-medium a-color-base a-text-normal"]'
items_title = driver.find_elements(By.CSS_SELECTOR, items_title_selector)
titles = [] # empty list to store each span element
for item in items_title:
    titles.append(item.text) # after the visible text is extracted, it is appended to the titles list
print(titles) # outputs the final titles list

add_cart_first_item_selector = 'span[class="a-button a-button-primary a-button-icon"]'
add_cart_first_item = driver.find_element(By.CSS_SELECTOR, add_cart_first_item_selector)
add_cart_first_item.click()
time.sleep(2)

# cart_selector = 'a[href="/-/es/cart?ref_=ewc_gtc]'
try:
    overlay = driver.find_element(By.CLASS_NAME, "a-changeover-inner")
    driver.execute_script("arguments[0].style.display = 'none';", overlay)
except:
    pass
cart = driver.find_element(By.PARTIAL_LINK_TEXT, 'Carrito')
cart.click()
# print(f"Se encontraron {len(cart)} elementos para el carrito")

# By.XPATH(“//input[@name=’q’]”)
# Descripción: Xpath, que significa XML Path Language, es un lenguaje que permite recorrer y procesar los elementos del DOM, por lo que es muy útil para encontrar un WebElement
# Desventajas: WebDriver utiliza las capacidades nativas de XPath de un navegador siempre que sea posible. En aquellos navegadores que no tienen soporte nativo de XPath, Selenium ha proporcionado su propia implementación. Esto puede llevar a un comportamiento inesperado a menos que se manejen esas diferencias en los distintos motores XPath. Se necesitan conocimientos de XPath.

# Usage: Uses XPath, a language for navigating the DOM (Document Object Model).
# Cons: Some browsers lack native XPath support, leading to inconsistent behavior across browsers.

payment_button_selector = '//input[@name="proceedToRetailCheckout"]'
payment_button = driver.find_element(By.XPATH, payment_button_selector)
payment_button.click()


# Usando JavaScript 
# Ej:WebElement element = (WebElement) ((JavascriptExecutor)driver).executeScript(“return $(‘.cheese’)[0]”);
# Descripción: Puede ejecutar código de JavaScript para encontrar un elemento siempre que devuelva un elemento DOM, este se convertirá automáticamente en un objeto WebElement
# Desventajas: Se necesitan conocimientos de JavaScript.

# Usage: Executes JavaScript code to manipulate or extract elements.
# Example: element = driver.execute_script("return document.querySelector('.cheese');")
# Cons: Requires understanding JavaScript, and improper use can affect performance or cause unexpected behavior.

go_back_two_pages_script = 'window.history.go(-2)' # equals executing driver.back() 2 times with python
driver.execute_script(go_back_two_pages_script)
time.sleep(2)

scroll_to_end_script = 'window.scrollTo(0, document.body.scrollHeight)'
driver.execute_script(scroll_to_end_script)
time.sleep(2)

driver.quit()